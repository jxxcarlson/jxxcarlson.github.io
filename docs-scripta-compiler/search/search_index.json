{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About the Scripta Compiler (( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . Here is documentation for both apps as well as Scripta Desktop . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. See also this conference talk at Lambda Days for an outline of the error recovery strategy. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"Home"},{"location":"#about-the-scripta-compiler","text":"(( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . Here is documentation for both apps as well as Scripta Desktop . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. See also this conference talk at Lambda Days for an outline of the error recovery strategy. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"About the Scripta Compiler"},{"location":"cli/","text":"CLI The ./CLI folder contains various CLI tools for testing and benchmarking. All use Albert Dahlin's elm/posix package. Here are the entries for .CLI/scripts.yaml : lxparse: elm-cli run --debug src/LXPB.elm Example: vr lxparse lxtest/a1.txt Test the MicroLaTeX block parser l0parse: elm-cli run --debug src/L0PB.elm Example: vr l0parse l0test/datatable.txt Test the L0 block parser rt: elm-cli run src/RoundTrip.elm Example: vr rt rt/para.txt bench: time elm-cli run src/Benchmark.elm Example: vr bench init 100 bench/harmonic.tex","title":"CLI"},{"location":"cli/#cli","text":"The ./CLI folder contains various CLI tools for testing and benchmarking. All use Albert Dahlin's elm/posix package. Here are the entries for .CLI/scripts.yaml : lxparse: elm-cli run --debug src/LXPB.elm Example: vr lxparse lxtest/a1.txt Test the MicroLaTeX block parser l0parse: elm-cli run --debug src/L0PB.elm Example: vr l0parse l0test/datatable.txt Test the L0 block parser rt: elm-cli run src/RoundTrip.elm Example: vr rt rt/para.txt bench: time elm-cli run src/Benchmark.elm Example: vr bench init 100 bench/harmonic.tex","title":"CLI"},{"location":"introduction/","text":"Introduction The Scripta compiler translates source text written in a markup language to an Elm representation of Html. Markup Languages The languages supported by Scripta are L0 microLaTeX XMarkdown Blocks The text of these markup languages should be thought of as structured into blocks, the content of which is written in an internal language . For example, in microLaTeX, one might have the text below. There are seven blocks, each of which is separated from its neighbor by an empty line. The first block is a paragraph; its content consists of plain text followed by the TeX macro expression \\italic{prime} followed by more plain text. Let's talk about \\italic{prime} numbers. \\begin{theorem} There are infinitely many primes $p$, and in fact there are infinitely many primes \\begin{equation} p \\equiv 1 \\ \\text{mod}\\ 4 \\end{equation} and also \\begin{equation} p \\equiv 1 \\ \\text{mod}\\ 8 \\end{equation} and so on. \\end{theorem} The first paragraph of the theorem was known to Euclid. The body of the theorem block consists of six blocks \u2014 the three paragraph blocks Let's talk ... , and also , and and so on . There also the two equation blocks. The blocks in the body of the theorem block constitute the \\italic{children} of the block. It is the job of the parser to (1) discover the forest structure, and (2) to parse the content of the blocks. Note that we can visualize the block structure as an outline, as below. PARAGRAPH THEOREM PARAGRPH EQUATION EQUATION PARAGRAPH PARAGRAM In some languages, e.g. L0 and Markdown, the block structure is literally given by the \"outline\" structure, that is, by indentation. Below is our example rewritten in L0: Let's talk about [italic prime] numbers. | theorem There are infinitely many primes $p$, and in fact there are infinitely many primes || equation p \\equiv 1 \\ \\text{mod}\\ 4 and also || equation p \\equiv 1 \\ \\text{mod}\\ 8 and so on. The first paragraph of the theorem was known to Euclid. Note that an outline is fully equivalent to a tree: |-- PARAGRAPH |-- THEOREM |- PARAGRAPH |- EQUATION |- EQUATION |- PARAGRAPH |- PARAGRAPH Internal Language While the surface syntax in L0, microLaTeX and XMarkdown depends on the language, the abstract syntax is the same for all tree. Indeed, text in the internal language always parses to Either String (List Expr) , where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta Block Definition In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status . render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render .","title":"Introduction"},{"location":"introduction/#introduction","text":"The Scripta compiler translates source text written in a markup language to an Elm representation of Html.","title":"Introduction"},{"location":"introduction/#markup-languages","text":"The languages supported by Scripta are L0 microLaTeX XMarkdown","title":"Markup Languages"},{"location":"introduction/#blocks","text":"The text of these markup languages should be thought of as structured into blocks, the content of which is written in an internal language . For example, in microLaTeX, one might have the text below. There are seven blocks, each of which is separated from its neighbor by an empty line. The first block is a paragraph; its content consists of plain text followed by the TeX macro expression \\italic{prime} followed by more plain text. Let's talk about \\italic{prime} numbers. \\begin{theorem} There are infinitely many primes $p$, and in fact there are infinitely many primes \\begin{equation} p \\equiv 1 \\ \\text{mod}\\ 4 \\end{equation} and also \\begin{equation} p \\equiv 1 \\ \\text{mod}\\ 8 \\end{equation} and so on. \\end{theorem} The first paragraph of the theorem was known to Euclid. The body of the theorem block consists of six blocks \u2014 the three paragraph blocks Let's talk ... , and also , and and so on . There also the two equation blocks. The blocks in the body of the theorem block constitute the \\italic{children} of the block. It is the job of the parser to (1) discover the forest structure, and (2) to parse the content of the blocks. Note that we can visualize the block structure as an outline, as below. PARAGRAPH THEOREM PARAGRPH EQUATION EQUATION PARAGRAPH PARAGRAM In some languages, e.g. L0 and Markdown, the block structure is literally given by the \"outline\" structure, that is, by indentation. Below is our example rewritten in L0: Let's talk about [italic prime] numbers. | theorem There are infinitely many primes $p$, and in fact there are infinitely many primes || equation p \\equiv 1 \\ \\text{mod}\\ 4 and also || equation p \\equiv 1 \\ \\text{mod}\\ 8 and so on. The first paragraph of the theorem was known to Euclid. Note that an outline is fully equivalent to a tree: |-- PARAGRAPH |-- THEOREM |- PARAGRAPH |- EQUATION |- EQUATION |- PARAGRAPH |- PARAGRAPH","title":"Blocks"},{"location":"introduction/#internal-language","text":"While the surface syntax in L0, microLaTeX and XMarkdown depends on the language, the abstract syntax is the same for all tree. Indeed, text in the internal language always parses to Either String (List Expr) , where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta","title":"Internal Language"},{"location":"introduction/#block-definition","text":"In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status . render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render .","title":"Block Definition"},{"location":"mkdocs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"overview/","text":"Overview Flowchart The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function","title":"Overview"},{"location":"overview/#overview","text":"","title":"Overview"},{"location":"overview/#flowchart","text":"The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function","title":"Flowchart"},{"location":"primitiveBlocks/","text":"Primitive Blocks Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } } Edit records type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData }","title":"Primitive Blocks"},{"location":"primitiveBlocks/#primitive-blocks","text":"Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } }","title":"Primitive Blocks"},{"location":"primitiveBlocks/#edit-records","text":"type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData }","title":"Edit records"},{"location":"tests/","text":"Tests To implement: round-trip tests for microLaTeX using the pretty-printer:","title":"Tests"},{"location":"tests/#tests","text":"To implement: round-trip tests for microLaTeX using the pretty-printer:","title":"Tests"}]}