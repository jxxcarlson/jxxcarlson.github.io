{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About the Scripta Compiler (( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"Home"},{"location":"#about-the-scripta-compiler","text":"(( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"About the Scripta Compiler"},{"location":"cli/","text":"CLI The ./CLI folder contains various CLI tools for testing and benchmarking. All use Albert Dahlin's elm/posix package. Here are the entries for .CLI/scripts.yaml : lxparse: elm-cli run --debug src/LXPB.elm Example: vr lxparse lxtest/a1.txt Test the MicroLaTeX block parser l0parse: elm-cli run --debug src/L0PB.elm Example: vr l0parse l0test/datatable.txt Test the L0 block parser rt: elm-cli run src/RoundTrip.elm Example: vr rt rt/para.txt bench: time elm-cli run src/Benchmark.elm Example: vr bench init 100 bench/harmonic.tex","title":"CLI"},{"location":"cli/#cli","text":"The ./CLI folder contains various CLI tools for testing and benchmarking. All use Albert Dahlin's elm/posix package. Here are the entries for .CLI/scripts.yaml : lxparse: elm-cli run --debug src/LXPB.elm Example: vr lxparse lxtest/a1.txt Test the MicroLaTeX block parser l0parse: elm-cli run --debug src/L0PB.elm Example: vr l0parse l0test/datatable.txt Test the L0 block parser rt: elm-cli run src/RoundTrip.elm Example: vr rt rt/para.txt bench: time elm-cli run src/Benchmark.elm Example: vr bench init 100 bench/harmonic.tex","title":"CLI"},{"location":"mkdocs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"overview/","text":"Overview of the Scripta Compiler The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The languages supported are L0 microLaTeX XMarkdown All three are parsed to a common syntax tree. This tree consists of blocks whose main content is the field Either String (List Expr) where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } } Flowchart The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render . type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData } In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status .","title":"Overview"},{"location":"overview/#overview-of-the-scripta-compiler","text":"The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The languages supported are L0 microLaTeX XMarkdown All three are parsed to a common syntax tree. This tree consists of blocks whose main content is the field Either String (List Expr) where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } }","title":"Overview of the Scripta Compiler"},{"location":"overview/#flowchart","text":"The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render . type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData } In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status .","title":"Flowchart"},{"location":"tests/","text":"Tests To implement: round-trip tests for microLaTeX using the pretty-printer:","title":"Tests"},{"location":"tests/#tests","text":"To implement: round-trip tests for microLaTeX using the pretty-printer:","title":"Tests"}]}