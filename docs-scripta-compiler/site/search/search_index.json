{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About the Scripta Compiler (( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"Home"},{"location":"#about-the-scripta-compiler","text":"(( This document is very much a work in progress. )) The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The markup languages supported are L0 microLaTeX XMarkdown For a very simple use of the Scripta compiler, see Scripta-example1 . For its use in a real web app, see Scripta.io . The compiler provides interactive, real-time editing with error recovery. See the overview for more information. This project has been partially supported by the Simons Foundation. We thank them for their generosity. Contact: James Carlson jxxcarlson at gmail @jxxcarlson on the Elm Slack @epsilon2718 on Twitter","title":"About the Scripta Compiler"},{"location":"mkdocs/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs"},{"location":"mkdocs/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"overview/","text":"Overview of the Scripta Compiler The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The languages supported are L0 microLaTeX XMarkdown All three are parsed to a common syntax tree. This tree consists of blocks whose main content is the field Either String (List Expr) where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } } Flowchart The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render . type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData } In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status .","title":"Overview"},{"location":"overview/#overview-of-the-scripta-compiler","text":"The Scripta compiler translates source text written in a markup language to an Elm representation of Html. The languages supported are L0 microLaTeX XMarkdown All three are parsed to a common syntax tree. This tree consists of blocks whose main content is the field Either String (List Expr) where type Expr = Fun String (List Expr) Meta | Text String Meta | Verbatim String String Meta Blocks have the rather elaborate type listed below. This complex structure is necessary for interactive real-time editing with error recovery. By real-time we mean that the rendered text is updated \"instantaneously\" in the browser as the user types in text. By interactive, we mean (for example) that click on the rendered text brings the associated source text into view while simultaneously highlighting it. In addition, if the user selects a block of source text and presses ctrl-S (S for 'sync'), the corresponding rendered text is brought into view and highlighted. type ExpressionBlock = ExpressionBlock { name : Maybe String , args : List String , properties : Dict String String , indent : Int , lineNumber : Int , numberOfLines : Int , id : String , tag : String , blockType : BlockType , content : Either String (List Expr) , messages : List String , sourceText : String , error : Maybe { error : String } }","title":"Overview of the Scripta Compiler"},{"location":"overview/#flowchart","text":"The Scripta compiler transforms text into Element Msg through a series of stages, as illustrated in the following figure. Below we describe these stages. The first step is to break the source text into chunks, namely a list of so-called primitive blocks . Ignoring for the moment the possibility of diff records and differential compilation, we traverse the left branch of the diagram, the penultimate step of which is the production of an EditRecord . Data of this type is transformed into an Elm representation of Html by the function render : Int -> Accumulator -> Settings -> ExpressionBlock -> Element MarkupMsg of module Block.Render . type alias EditRecord chunk parsedChunk accumulator = { chunks : List chunk , parsed : List parsedChunk , tree : List (Tree parsedChunk) , accumulator : accumulator , lang : Language , messages : List String , initialData : InitialData } In the case of L0 and XMarkdown, a primitive block is defined by type alias PrimitiveBlock = { indent : Int , lineNumber : Int , position : Int , content : List String , name : Maybe String , args : List String , properties : Dict String String , sourceText : String , blockType : PrimitiveBlockType , error : Maybe { error : String } } In the case of MicroLaTeX, there are two additional fields, level: Int and status: Status .","title":"Flowchart"}]}