{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Scripta Project Scripta is an editing and publishing system for technical documents (mathematics, physics, etc.). It consists of two components, the web app Scripta.io and the the Scripta compiler . The Scripta compiler supports three markup languages L0 MicroLaTeX XMarkdown L0 has a syntax inspired by Lisp; MicroLaTeX is an implementation of LaTeX, and XMarkdown is like Markdown, but with some extra features, e.g., TeX-style mathematical text. Both the app and the compiler are written in Elm , a pure functional language that compiles to Javascript. The app also uses the Lamdera framework, which permits one to write both the front and the backend in Elm. See this short note on Lamdera . For a quick demo of the compiler as it applies to microLaTeX, please see this example app . You can edit the text of this app at will.","title":"Home"},{"location":"#the-scripta-project","text":"Scripta is an editing and publishing system for technical documents (mathematics, physics, etc.). It consists of two components, the web app Scripta.io and the the Scripta compiler . The Scripta compiler supports three markup languages L0 MicroLaTeX XMarkdown L0 has a syntax inspired by Lisp; MicroLaTeX is an implementation of LaTeX, and XMarkdown is like Markdown, but with some extra features, e.g., TeX-style mathematical text. Both the app and the compiler are written in Elm , a pure functional language that compiles to Javascript. The app also uses the Lamdera framework, which permits one to write both the front and the backend in Elm. See this short note on Lamdera . For a quick demo of the compiler as it applies to microLaTeX, please see this example app . You can edit the text of this app at will.","title":"The Scripta Project"},{"location":"L0/","text":"The L0 Markup Language The L0 Markup language takes inspiration from Lisp. Text in L0 consists of blocks and elements . An element is a span of ordinary text or a function element like [i blocks] , where i (for \"italic\") is the function and the rest of the text up to the matching right bracket, in this case \"blocks\", is the function argument. Function elements can be nested, e.g., [i [b blocks]] . In this case \"blocks\" is rendered in bold italic. One could also write [i special [b blocks]] , in which case \"special\" would be italicized and \"blocks\" would be rendered in bold italic. There are a few special elements: text enclosed in backticks for inline code, and text enclosed in dollar signs for inline mathematics, e.g., $a^2 + b^2 = c^2$. There are three kinds of blocks: anonymous blocks (paragraphs), named blocks, and verbatim blocks. Blocks are bounded above and below by one or more blank lines. An anonymous block, aka paragraph, is a sequence of elements containing no blank lines. Named and verbatim blocks consist of a header and a body. The header is a line of the form | Name Arguments in the case of a named block. In the case of a verbatim block, the header takes the form || Name Arguments . The body is a sequence of elements containing no blank lines. Blocks may be indented, thus defining a tree structure.","title":"The L0 Markup Language"},{"location":"L0/#the-l0-markup-language","text":"The L0 Markup language takes inspiration from Lisp. Text in L0 consists of blocks and elements . An element is a span of ordinary text or a function element like [i blocks] , where i (for \"italic\") is the function and the rest of the text up to the matching right bracket, in this case \"blocks\", is the function argument. Function elements can be nested, e.g., [i [b blocks]] . In this case \"blocks\" is rendered in bold italic. One could also write [i special [b blocks]] , in which case \"special\" would be italicized and \"blocks\" would be rendered in bold italic. There are a few special elements: text enclosed in backticks for inline code, and text enclosed in dollar signs for inline mathematics, e.g., $a^2 + b^2 = c^2$. There are three kinds of blocks: anonymous blocks (paragraphs), named blocks, and verbatim blocks. Blocks are bounded above and below by one or more blank lines. An anonymous block, aka paragraph, is a sequence of elements containing no blank lines. Named and verbatim blocks consist of a header and a body. The header is a line of the form | Name Arguments in the case of a named block. In the case of a verbatim block, the header takes the form || Name Arguments . The body is a sequence of elements containing no blank lines. Blocks may be indented, thus defining a tree structure.","title":"The L0 Markup Language"},{"location":"about/","text":"Scripta is an editing system for a small family of markup languages: L0 MicroLaTeX XMarkdown","title":"About"},{"location":"collectionDocs/","text":"Collection Documents A collection document is a collection of links to other documents. Example Here is the source text: | title Quantum Mechanics Notes [tags jxxcarlson:quantum-mechanics-notes, collection] | collection | document jxxcarlson:qmnotes-trajectories-uncertainty Trajectories and Uncertainty | document jxxcarlson:wave-packets-dispersion Wave Packets and the Dispersion Relation ... About the document format A collection document is normally written in the L0 markup language The word collection must occur in the tag element, and the block | collection is mandatory. Note to self: simplify this API! Following this block, there is a series of | document blocks. Such a block takes a single argument, which is either the document id or the document slug, which has the form USERNAME:REFERENCE . The document blocks are rendered as ilinks (internal links). Internal links are handled by Lamdera via websockets. Http links would reload the app, which is a bad idea. Creating a collection document The bare-metal way to create and update a collection document is to create an ordinary document, then edit its text following the format described above. One can also use the New: Collection button in the Scripta app. The button calls Frontend.Update.newCollection . Here, in pictures, is the full data flow: Data flow for creating a collection document Continuing in words, Frontend.Update.newCollection calls Frontend.Update.makeDocument , which invokes the command Lamdera.sendToBackend (CreateDocument model.currentUser newDoc) The message CreateDocument calls Backend.Document.create , which is responsible for creating the document, adding to the application store, and sending the resulting document back to the frontend via Lamdera.sendToFrontend clientId (ReceivedNewDocument handling doc) Adding a new document to a collection","title":"Collection Documents"},{"location":"collectionDocs/#collection-documents","text":"A collection document is a collection of links to other documents.","title":"Collection Documents"},{"location":"collectionDocs/#example","text":"Here is the source text: | title Quantum Mechanics Notes [tags jxxcarlson:quantum-mechanics-notes, collection] | collection | document jxxcarlson:qmnotes-trajectories-uncertainty Trajectories and Uncertainty | document jxxcarlson:wave-packets-dispersion Wave Packets and the Dispersion Relation ...","title":"Example"},{"location":"collectionDocs/#about-the-document-format","text":"A collection document is normally written in the L0 markup language The word collection must occur in the tag element, and the block | collection is mandatory. Note to self: simplify this API! Following this block, there is a series of | document blocks. Such a block takes a single argument, which is either the document id or the document slug, which has the form USERNAME:REFERENCE . The document blocks are rendered as ilinks (internal links). Internal links are handled by Lamdera via websockets. Http links would reload the app, which is a bad idea.","title":"About the document format"},{"location":"collectionDocs/#creating-a-collection-document","text":"The bare-metal way to create and update a collection document is to create an ordinary document, then edit its text following the format described above. One can also use the New: Collection button in the Scripta app. The button calls Frontend.Update.newCollection . Here, in pictures, is the full data flow: Data flow for creating a collection document Continuing in words, Frontend.Update.newCollection calls Frontend.Update.makeDocument , which invokes the command Lamdera.sendToBackend (CreateDocument model.currentUser newDoc) The message CreateDocument calls Backend.Document.create , which is responsible for creating the document, adding to the application store, and sending the resulting document back to the frontend via Lamdera.sendToFrontend clientId (ReceivedNewDocument handling doc)","title":"Creating a collection document"},{"location":"collectionDocs/#adding-a-new-document-to-a-collection","text":"","title":"Adding a new document to a collection"},{"location":"lamdera/","text":"Lamdera As a guide to what follows, we describe briefly the architecture of a Lamdera app. The basic idea is that there is a frontend and a backend, the two communicating via a message protocol over websockets. Thus, to fetch a document from the backend, the frontend may issue the command Lamdera.sendToBackend (FetchDocumentById SimpleHandling doc.id) The backend would then retrieve the document using the id, and if found, send it to the frontend via Lamdera.sendToFrontend clientId (ReceivedDocument SimpledHandling document)","title":"Lamdera"},{"location":"lamdera/#lamdera","text":"As a guide to what follows, we describe briefly the architecture of a Lamdera app. The basic idea is that there is a frontend and a backend, the two communicating via a message protocol over websockets. Thus, to fetch a document from the backend, the frontend may issue the command Lamdera.sendToBackend (FetchDocumentById SimpleHandling doc.id) The backend would then retrieve the document using the id, and if found, send it to the frontend via Lamdera.sendToFrontend clientId (ReceivedDocument SimpledHandling document)","title":"Lamdera"},{"location":"mkdocs-info/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs Info"},{"location":"mkdocs-info/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs-info/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs-info/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"newdocs/","text":"Making a New Document A new document may stand by itself or be intended as a member of an existing smart folder or collection of documents. The Frontend.Update.newDocument must take into account these eventualities: Suppose that the current master document is a smart folder. Then creation of a new document should attach that document to the smart folder. See refreshSmartFolderCmd . Suppose that the current master document is a collection and that one of its members is the current document. Then creation of a new document should add it to the collection, and it should be positioned immediately after the current document. See updateCollectionCmd . In both cases, the new document should be the selected document in the index for the folder or collection (this is not currently the case.)","title":"Making a New Document"},{"location":"newdocs/#making-a-new-document","text":"A new document may stand by itself or be intended as a member of an existing smart folder or collection of documents. The Frontend.Update.newDocument must take into account these eventualities: Suppose that the current master document is a smart folder. Then creation of a new document should attach that document to the smart folder. See refreshSmartFolderCmd . Suppose that the current master document is a collection and that one of its members is the current document. Then creation of a new document should add it to the collection, and it should be positioned immediately after the current document. See updateCollectionCmd . In both cases, the new document should be the selected document in the index for the folder or collection (this is not currently the case.)","title":"Making a New Document"},{"location":"search/","text":"Search Search by Abstract Queries for documents using jxxcarlson/elm-text-search look like the following: \"foo\": retrieve documents whose abastract digest contains \"foo\" \"foo bar\": retrieve documents whose abastract digest contains \"foo\" and \"bar\" \"foo -bar\": retrieve documents whose abastract digest contains \"foo\" but not \"bar\" \"foo | bar\": retrieve documents whose abastract digest contains \"foo\" or \"bar\" \"'foo bar'\": retrieve documents whose abastract digest contains the phrase \"foo bar\". This search excludes documents containing \"bar foo\", \"foo baz bar\", etc. To be technical any query in disjunctive normal form is accepted. A document abstract has type type alias Abstract = { title : String , author : String , abstract : String , tags : String , digest : String } The digest is computed by toString : Abstract -> String toString a = [ a.title, a.author, a.tags ] |> String.join \"; \" Abstracts are held in the field abstractDict : Dict DocId Abstract of the backend model. This dictionary is updated every Config.backendTickSeconds by the update function of the backend model: Tick newTime -> -- Do regular tasks ( { model | currentTime = newTime } |> updateAbstracts |> Backend.Update.updateDocumentTags , Command.none ) Code Searches are initiated by the Search clause of Frontend.update . This clause invokes Frontend.Search.search model which send the message Types.SearchForDocuments StandardHandling model.currentUser model.inputSearchKey to the backend where Backend.Search.withQuery is called. The real work is done by this function from module TextSearch.Search (jxxcarlson/elm-text-search): match = matchWithQueryString identity Search.NotCaseSensitive query Query strings for Search.queryWithString look like foo bar , foo -bar , and foo -bar | baz . The first will match strings contaning both foo and bar , the second will match strings matching foo but not bar , and the third will match either strings matching foo but not bar or strings matching baz . That is, the query string represents a logical expression in disjunctive normal form. NOTE. There are other ways of invoking a search. We need more order and less chaos here.","title":"Search"},{"location":"search/#search","text":"","title":"Search"},{"location":"search/#search-by-abstract","text":"Queries for documents using jxxcarlson/elm-text-search look like the following: \"foo\": retrieve documents whose abastract digest contains \"foo\" \"foo bar\": retrieve documents whose abastract digest contains \"foo\" and \"bar\" \"foo -bar\": retrieve documents whose abastract digest contains \"foo\" but not \"bar\" \"foo | bar\": retrieve documents whose abastract digest contains \"foo\" or \"bar\" \"'foo bar'\": retrieve documents whose abastract digest contains the phrase \"foo bar\". This search excludes documents containing \"bar foo\", \"foo baz bar\", etc. To be technical any query in disjunctive normal form is accepted. A document abstract has type type alias Abstract = { title : String , author : String , abstract : String , tags : String , digest : String } The digest is computed by toString : Abstract -> String toString a = [ a.title, a.author, a.tags ] |> String.join \"; \" Abstracts are held in the field abstractDict : Dict DocId Abstract of the backend model. This dictionary is updated every Config.backendTickSeconds by the update function of the backend model: Tick newTime -> -- Do regular tasks ( { model | currentTime = newTime } |> updateAbstracts |> Backend.Update.updateDocumentTags , Command.none )","title":"Search by Abstract"},{"location":"search/#code","text":"Searches are initiated by the Search clause of Frontend.update . This clause invokes Frontend.Search.search model which send the message Types.SearchForDocuments StandardHandling model.currentUser model.inputSearchKey to the backend where Backend.Search.withQuery is called. The real work is done by this function from module TextSearch.Search (jxxcarlson/elm-text-search): match = matchWithQueryString identity Search.NotCaseSensitive query Query strings for Search.queryWithString look like foo bar , foo -bar , and foo -bar | baz . The first will match strings contaning both foo and bar , the second will match strings matching foo but not bar , and the third will match either strings matching foo but not bar or strings matching baz . That is, the query string represents a logical expression in disjunctive normal form. NOTE. There are other ways of invoking a search. We need more order and less chaos here.","title":"Code"},{"location":"smartfolders/","text":"Smart Folders A smart folder is a way of automatically producing a collection document, where the documents in the collection are those (belonging to the user) with a specified tag. Such a collection is created at the backend by the function SmartFolder.makeCollectionDocumentCmd . This function is invoked indirectly from the frontend by the function SmartFolder.makeCollectionDocument . The format of a smart folder document is | title Notes (Foo) [tags :folder, gettag:foo] The resulting collection document will be populated by all of the user's documents tagged with \"foo\". The old format is for the time being still operational: | title Notes (Foo) [tags :folder] | type folder get:foo ; Creating a Smart Folder A smart folder is created by the function SmartFolder.create . It creates the document and sends to to the backend via the message CreateDocument , which invokes the function Backend.Document.create Sort options The default sort option is to sort titles alphabetically (A to Z). The sort option may be changed by specifying a tag: sort:created-oldest-first sort:created-newest-first sort:modified-oldest-first sort:modified-newest-first sort:a-to-z sort:z-to-a","title":"Smart Folders"},{"location":"smartfolders/#smart-folders","text":"A smart folder is a way of automatically producing a collection document, where the documents in the collection are those (belonging to the user) with a specified tag. Such a collection is created at the backend by the function SmartFolder.makeCollectionDocumentCmd . This function is invoked indirectly from the frontend by the function SmartFolder.makeCollectionDocument . The format of a smart folder document is | title Notes (Foo) [tags :folder, gettag:foo] The resulting collection document will be populated by all of the user's documents tagged with \"foo\". The old format is for the time being still operational: | title Notes (Foo) [tags :folder] | type folder get:foo ;","title":"Smart Folders"},{"location":"smartfolders/#creating-a-smart-folder","text":"A smart folder is created by the function SmartFolder.create . It creates the document and sends to to the backend via the message CreateDocument , which invokes the function Backend.Document.create","title":"Creating a Smart Folder"},{"location":"smartfolders/#sort-options","text":"The default sort option is to sort titles alphabetically (A to Z). The sort option may be changed by specifying a tag: sort:created-oldest-first sort:created-newest-first sort:modified-oldest-first sort:modified-newest-first sort:a-to-z sort:z-to-a","title":"Sort options"}]}