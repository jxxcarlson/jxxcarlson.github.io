{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Scripta Developer Docs The Scripta Project Scripta is an editing and publishing system for technical documents (mathematics, physics, etc.). It consists of four components Demo app . No login required. You can edit the text you see there or create something entirely new. Your edits will not be saved. Scripta.io , a web app with a searchable store of documents. No login required to search for and read public documents. Scripta Desktop , for Mac OS (fat binary), soon to be cross-compiled for Linux and Windows. A desktop version of Scripta.io. The Scripta compiler . This is the engine which makes all of the above work. The compiler and the applications are written in Elm , a pure functional language that compiles to Javascript. See the Tech Stack section below for more information. Source code: Scripta Compiler and Demo App Scripta Desktop Scripta.io: not currently open source Screenshots Scripta.io, a notebbook document Direct link Scripta.io, an ordinary document Direct link Scripta Desktop Download page Compiler The Scripta compiler supports three markup languages L0 MicroLaTeX XMarkdown L0 has a syntax inspired by Lisp; MicroLaTeX is an implementation of LaTeX, and XMarkdown is like Markdown, but with some extra features, e.g., TeX-style mathematical text. See this live example for a simple demonstration of microLaTeX ( source code here ). You can edit the text of the example app at will. Scripta.io is a full-featured use case that makes use of the compiler's error recovery facilities and which implements synchronization of source and rendered text: click on rendered text to highlight and bring into view the corresponding source text; select a block of source text and press ctrl-S (for \"sync\") to highlight the corresponding rendered text and bring it into view. The compiler is open-source, with the code hosted on Github ) and with some documentation (work in progress) . See also the example source code Tech stack Both the app and the compiler are written in Elm , a pure functional language that compiles to Javascript. The app also uses the Lamdera framework, which permits one to write both the front and the backend in Elm. See this short note on Lamdera . Mathematical text is rendered using KaTeX and the editor relies on Codemirror 6 . The interface to Elm for both of these is via custom elements. Scripta Desktop is built with Tauri.app . See this article for some notes on how it was assembled. Briefly, Tauri is a way of converting a web app built with most any language/framework including Elm into a desktop app. It has both good security and small asset size. Note Most of the rest of this document concerns the web app and is intended to help the app developers.","title":"Home"},{"location":"#scripta-developer-docs","text":"","title":"Scripta Developer Docs"},{"location":"#the-scripta-project","text":"Scripta is an editing and publishing system for technical documents (mathematics, physics, etc.). It consists of four components Demo app . No login required. You can edit the text you see there or create something entirely new. Your edits will not be saved. Scripta.io , a web app with a searchable store of documents. No login required to search for and read public documents. Scripta Desktop , for Mac OS (fat binary), soon to be cross-compiled for Linux and Windows. A desktop version of Scripta.io. The Scripta compiler . This is the engine which makes all of the above work. The compiler and the applications are written in Elm , a pure functional language that compiles to Javascript. See the Tech Stack section below for more information. Source code: Scripta Compiler and Demo App Scripta Desktop Scripta.io: not currently open source","title":"The Scripta Project"},{"location":"#screenshots","text":"","title":"Screenshots"},{"location":"#scriptaio-a-notebbook-document","text":"Direct link","title":"Scripta.io, a notebbook document"},{"location":"#scriptaio-an-ordinary-document","text":"Direct link","title":"Scripta.io, an ordinary document"},{"location":"#scripta-desktop","text":"Download page","title":"Scripta Desktop"},{"location":"#compiler","text":"The Scripta compiler supports three markup languages L0 MicroLaTeX XMarkdown L0 has a syntax inspired by Lisp; MicroLaTeX is an implementation of LaTeX, and XMarkdown is like Markdown, but with some extra features, e.g., TeX-style mathematical text. See this live example for a simple demonstration of microLaTeX ( source code here ). You can edit the text of the example app at will. Scripta.io is a full-featured use case that makes use of the compiler's error recovery facilities and which implements synchronization of source and rendered text: click on rendered text to highlight and bring into view the corresponding source text; select a block of source text and press ctrl-S (for \"sync\") to highlight the corresponding rendered text and bring it into view. The compiler is open-source, with the code hosted on Github ) and with some documentation (work in progress) . See also the example source code","title":"Compiler"},{"location":"#tech-stack","text":"Both the app and the compiler are written in Elm , a pure functional language that compiles to Javascript. The app also uses the Lamdera framework, which permits one to write both the front and the backend in Elm. See this short note on Lamdera . Mathematical text is rendered using KaTeX and the editor relies on Codemirror 6 . The interface to Elm for both of these is via custom elements. Scripta Desktop is built with Tauri.app . See this article for some notes on how it was assembled. Briefly, Tauri is a way of converting a web app built with most any language/framework including Elm into a desktop app. It has both good security and small asset size.","title":"Tech stack"},{"location":"#note","text":"Most of the rest of this document concerns the web app and is intended to help the app developers.","title":"Note"},{"location":"L0/","text":"The L0 Markup Language The L0 Markup language takes inspiration from Lisp. Text in L0 consists of blocks and elements . An element is a span of ordinary text or a function element like [i blocks] , where i (for \"italic\") is the function and the rest of the text up to the matching right bracket, in this case \"blocks\", is the function argument. Function elements can be nested, e.g., [i [b blocks]] . In this case \"blocks\" is rendered in bold italic. One could also write [i special [b blocks]] , in which case \"special\" would be italicized and \"blocks\" would be rendered in bold italic. There are a few special elements: text enclosed in backticks for inline code, and text enclosed in dollar signs for inline mathematics, e.g., $a^2 + b^2 = c^2$. There are three kinds of blocks: anonymous blocks (paragraphs), named blocks, and verbatim blocks. Blocks are bounded above and below by one or more blank lines. An anonymous block, aka paragraph, is a sequence of elements containing no blank lines. Named and verbatim blocks consist of a header and a body. The header is a line of the form | Name Arguments in the case of a named block. In the case of a verbatim block, the header takes the form || Name Arguments . The body is a sequence of elements containing no blank lines. Blocks may be indented, thus defining a tree structure.","title":"The L0 Markup Language"},{"location":"L0/#the-l0-markup-language","text":"The L0 Markup language takes inspiration from Lisp. Text in L0 consists of blocks and elements . An element is a span of ordinary text or a function element like [i blocks] , where i (for \"italic\") is the function and the rest of the text up to the matching right bracket, in this case \"blocks\", is the function argument. Function elements can be nested, e.g., [i [b blocks]] . In this case \"blocks\" is rendered in bold italic. One could also write [i special [b blocks]] , in which case \"special\" would be italicized and \"blocks\" would be rendered in bold italic. There are a few special elements: text enclosed in backticks for inline code, and text enclosed in dollar signs for inline mathematics, e.g., $a^2 + b^2 = c^2$. There are three kinds of blocks: anonymous blocks (paragraphs), named blocks, and verbatim blocks. Blocks are bounded above and below by one or more blank lines. An anonymous block, aka paragraph, is a sequence of elements containing no blank lines. Named and verbatim blocks consist of a header and a body. The header is a line of the form | Name Arguments in the case of a named block. In the case of a verbatim block, the header takes the form || Name Arguments . The body is a sequence of elements containing no blank lines. Blocks may be indented, thus defining a tree structure.","title":"The L0 Markup Language"},{"location":"collectionDocs/","text":"Collection Documents A collection document is a collection of links to other documents. Example Here is the source text: | title Quantum Mechanics Notes [tags jxxcarlson:quantum-mechanics-notes, collection] | collection | document jxxcarlson:qmnotes-trajectories-uncertainty Trajectories and Uncertainty | document jxxcarlson:wave-packets-dispersion Wave Packets and the Dispersion Relation ... About the document format A collection document is normally written in the L0 markup language The word collection must occur in the tag element, and the block | collection is mandatory. Note to self: simplify this API! Following this block, there is a series of | document blocks. Such a block takes a single argument, which is either the document id or the document slug, which has the form USERNAME:REFERENCE . The document blocks are rendered as ilinks (internal links). Internal links are handled by Lamdera via websockets. Http links would reload the app, which is a bad idea. Creating a collection document The bare-metal way to create and update a collection document is to create an ordinary document, then edit its text following the format described above. One can also use the New: Collection button in the Scripta app. The button calls Frontend.Update.newCollection . Here, in pictures, is the full data flow: Data flow for creating a collection document Continuing in words, Frontend.Update.newCollection calls Frontend.Update.makeDocument , which invokes the command Lamdera.sendToBackend (CreateDocument model.currentUser newDoc) The message CreateDocument calls Backend.Document.create , which is responsible for creating the document, adding to the application store, and sending the resulting document back to the frontend via Lamdera.sendToFrontend clientId (ReceivedNewDocument handling doc) Adding a new document to a collection","title":"Collection Documents"},{"location":"collectionDocs/#collection-documents","text":"A collection document is a collection of links to other documents.","title":"Collection Documents"},{"location":"collectionDocs/#example","text":"Here is the source text: | title Quantum Mechanics Notes [tags jxxcarlson:quantum-mechanics-notes, collection] | collection | document jxxcarlson:qmnotes-trajectories-uncertainty Trajectories and Uncertainty | document jxxcarlson:wave-packets-dispersion Wave Packets and the Dispersion Relation ...","title":"Example"},{"location":"collectionDocs/#about-the-document-format","text":"A collection document is normally written in the L0 markup language The word collection must occur in the tag element, and the block | collection is mandatory. Note to self: simplify this API! Following this block, there is a series of | document blocks. Such a block takes a single argument, which is either the document id or the document slug, which has the form USERNAME:REFERENCE . The document blocks are rendered as ilinks (internal links). Internal links are handled by Lamdera via websockets. Http links would reload the app, which is a bad idea.","title":"About the document format"},{"location":"collectionDocs/#creating-a-collection-document","text":"The bare-metal way to create and update a collection document is to create an ordinary document, then edit its text following the format described above. One can also use the New: Collection button in the Scripta app. The button calls Frontend.Update.newCollection . Here, in pictures, is the full data flow: Data flow for creating a collection document Continuing in words, Frontend.Update.newCollection calls Frontend.Update.makeDocument , which invokes the command Lamdera.sendToBackend (CreateDocument model.currentUser newDoc) The message CreateDocument calls Backend.Document.create , which is responsible for creating the document, adding to the application store, and sending the resulting document back to the frontend via Lamdera.sendToFrontend clientId (ReceivedNewDocument handling doc)","title":"Creating a collection document"},{"location":"collectionDocs/#adding-a-new-document-to-a-collection","text":"","title":"Adding a new document to a collection"},{"location":"documentIndex/","text":"Document Index","title":"Document Index"},{"location":"documentIndex/#document-index","text":"","title":"Document Index"},{"location":"lamdera/","text":"Lamdera As a guide to what follows, we describe briefly the architecture of a Lamdera app. The basic idea is that there is a frontend and a backend, the two communicating via a message protocol over websockets. Thus, to fetch a document from the backend, the frontend may issue the command Lamdera.sendToBackend (FetchDocumentById SimpleHandling doc.id) The backend would then retrieve the document using the id, and if found, send it to the frontend via Lamdera.sendToFrontend clientId (ReceivedDocument SimpledHandling document)","title":"Lamdera"},{"location":"lamdera/#lamdera","text":"As a guide to what follows, we describe briefly the architecture of a Lamdera app. The basic idea is that there is a frontend and a backend, the two communicating via a message protocol over websockets. Thus, to fetch a document from the backend, the frontend may issue the command Lamdera.sendToBackend (FetchDocumentById SimpleHandling doc.id) The backend would then retrieve the document using the id, and if found, send it to the frontend via Lamdera.sendToFrontend clientId (ReceivedDocument SimpledHandling document)","title":"Lamdera"},{"location":"mkdocs-info/","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Mkdocs Info"},{"location":"mkdocs-info/#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"mkdocs-info/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"mkdocs-info/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"newdocs/","text":"Making a New Document A new document may stand by itself or be intended as a member of an existing smart folder or collection of documents. The Frontend.Update.newDocument must take into account these eventualities: Suppose that the current master document is a smart folder. Then creation of a new document should attach that document to the smart folder. See refreshSmartFolderCmd . Suppose that the current master document is a collection and that one of its members is the current document. Then creation of a new document should add it to the collection, and it should be positioned immediately after the current document. See updateCollectionCmd . In both cases, the new document should be the selected document in the index for the folder or collection (this is not currently the case.)","title":"Making a New Document"},{"location":"newdocs/#making-a-new-document","text":"A new document may stand by itself or be intended as a member of an existing smart folder or collection of documents. The Frontend.Update.newDocument must take into account these eventualities: Suppose that the current master document is a smart folder. Then creation of a new document should attach that document to the smart folder. See refreshSmartFolderCmd . Suppose that the current master document is a collection and that one of its members is the current document. Then creation of a new document should add it to the collection, and it should be positioned immediately after the current document. See updateCollectionCmd . In both cases, the new document should be the selected document in the index for the folder or collection (this is not currently the case.)","title":"Making a New Document"},{"location":"openDoc/","text":"Opening a document When a document is opened by clicking on it in the index panel, it needs to be made current, that is, model.currentDocument is set to the document in question. The functions for this operation are found in module Frontend.CurrentDocuent and the flow of messages that this action initiates are set out in the diagram below. The blue lines are activated if (1) there are additional documents to be loaded, e.g., macro files for microLaTeX documents or if (2) the document is is a collection document or live folder. It is important in this process that the correct index panel be used ...","title":"Opening a Document"},{"location":"openDoc/#opening-a-document","text":"When a document is opened by clicking on it in the index panel, it needs to be made current, that is, model.currentDocument is set to the document in question. The functions for this operation are found in module Frontend.CurrentDocuent and the flow of messages that this action initiates are set out in the diagram below. The blue lines are activated if (1) there are additional documents to be loaded, e.g., macro files for microLaTeX documents or if (2) the document is is a collection document or live folder. It is important in this process that the correct index panel be used ...","title":"Opening a document"},{"location":"search/","text":"Search Search by Abstract The abstract of a document summarizes information about a document, e.g, its title, author and tags. Thus a search by abstract with query \"einstein\" might match \"einstein\" in the title, in the author field, or in a document tag. Queries for documents using jxxcarlson/elm-text-search look like the following: \"foo\": retrieve documents whose abstract digest contains \"foo\" \"foo bar\": retrieve documents whose abstract digest contains \"foo\" and \"bar\" \"foo -bar\": retrieve documents whose abstract digest contains \"foo\" but not \"bar\" \"foo | bar\": retrieve documents whose abstract digest contains \"foo\" or \"bar\" \"'foo bar'\": Note the single quotes! \u2014 retrieve documents whose abstract digest contains the phrase \"foo bar\". This search excludes documents containing \"bar foo\", \"foo baz bar\", etc. To be technical, any query in disjunctive normal form is is accepted. In addition, a query can contain the fragment \":r\", which signifies a random sample (max 20) of the documents which match the search query. Thus the query \"atom:r\" returns a random sample of documents which match \"atom\", while the query \":r\" returns a random sample of documents matching the ambient conditions, e.g., begin public or belong to the current user. For more complex queries, the fragment \":r\" can appear by itself. Document Abstracts A document abstract has type type alias Abstract = { title : String , author : String , abstract : String , tags : String , digest : String } The digest is computed by toString : Abstract -> String toString a = [ a.title, a.author, a.tags ] |> String.join \"; \" Abstracts are held in the field abstractDict : Dict DocId Abstract of the backend model. This dictionary is updated every Config.backendTickSeconds by the update function of the backend model: Tick newTime -> -- Do regular tasks ( { model | currentTime = newTime } |> updateAbstracts |> Backend.Update.updateDocumentTags , Command.none ) Initiating a Search by Abstract User document searches are initiated by the Search clause of Frontend.update . This clause invokes Frontend.Search.search which send a message of type SearchForDocuments DocumentHandling SearchMode QueryString to the back end, where QueryString is an alias for String and where type SearchMode = UserSearch Username | PublicSearch This message is handled by -- module Backend.Search forDocuments : BackendModel -> ClientId -> DocumentHandling -> SearchMode -> Types.QueryString -> ( BackendModel, Command BackendOnly ToFrontend backendMsg ) All searches that can be routed through this function should be. Search by Tag ((Under Construction))","title":"Search"},{"location":"search/#search","text":"","title":"Search"},{"location":"search/#search-by-abstract","text":"The abstract of a document summarizes information about a document, e.g, its title, author and tags. Thus a search by abstract with query \"einstein\" might match \"einstein\" in the title, in the author field, or in a document tag. Queries for documents using jxxcarlson/elm-text-search look like the following: \"foo\": retrieve documents whose abstract digest contains \"foo\" \"foo bar\": retrieve documents whose abstract digest contains \"foo\" and \"bar\" \"foo -bar\": retrieve documents whose abstract digest contains \"foo\" but not \"bar\" \"foo | bar\": retrieve documents whose abstract digest contains \"foo\" or \"bar\" \"'foo bar'\": Note the single quotes! \u2014 retrieve documents whose abstract digest contains the phrase \"foo bar\". This search excludes documents containing \"bar foo\", \"foo baz bar\", etc. To be technical, any query in disjunctive normal form is is accepted. In addition, a query can contain the fragment \":r\", which signifies a random sample (max 20) of the documents which match the search query. Thus the query \"atom:r\" returns a random sample of documents which match \"atom\", while the query \":r\" returns a random sample of documents matching the ambient conditions, e.g., begin public or belong to the current user. For more complex queries, the fragment \":r\" can appear by itself.","title":"Search by Abstract"},{"location":"search/#document-abstracts","text":"A document abstract has type type alias Abstract = { title : String , author : String , abstract : String , tags : String , digest : String } The digest is computed by toString : Abstract -> String toString a = [ a.title, a.author, a.tags ] |> String.join \"; \" Abstracts are held in the field abstractDict : Dict DocId Abstract of the backend model. This dictionary is updated every Config.backendTickSeconds by the update function of the backend model: Tick newTime -> -- Do regular tasks ( { model | currentTime = newTime } |> updateAbstracts |> Backend.Update.updateDocumentTags , Command.none )","title":"Document Abstracts"},{"location":"search/#initiating-a-search-by-abstract","text":"User document searches are initiated by the Search clause of Frontend.update . This clause invokes Frontend.Search.search which send a message of type SearchForDocuments DocumentHandling SearchMode QueryString to the back end, where QueryString is an alias for String and where type SearchMode = UserSearch Username | PublicSearch This message is handled by -- module Backend.Search forDocuments : BackendModel -> ClientId -> DocumentHandling -> SearchMode -> Types.QueryString -> ( BackendModel, Command BackendOnly ToFrontend backendMsg ) All searches that can be routed through this function should be.","title":"Initiating a Search by Abstract"},{"location":"search/#search-by-tag","text":"((Under Construction))","title":"Search by Tag"},{"location":"smartfolders/","text":"Smart Folders A smart folder is a way of automatically producing a collection document, where the documents in the collection are those (belonging to the user) with a specified tag. Such a collection is created at the backend by the function SmartFolder.makeCollectionDocumentCmd . This function is invoked indirectly from the frontend by the function SmartFolder.makeCollectionDocument . The format of a smart folder document is | title Notes (Foo) [tags :folder, gettag:foo] The resulting collection document will be populated by all of the user's documents tagged with \"foo\". The old format is for the time being still operational: | title Notes (Foo) [tags :folder] | type folder get:foo ; Creating a Smart Folder A smart folder is created by the function SmartFolder.create . It creates the document and sends to to the backend via the message CreateDocument , which invokes the function Backend.Document.create Sort options The default sort option is to sort titles alphabetically (A to Z). The sort option may be changed by specifying a tag: sort:created-oldest-first sort:created-newest-first sort:modified-oldest-first sort:modified-newest-first sort:a-to-z sort:z-to-a Rendering a smart folder When the user click on a smart folder, the normal chaing of function calls is activated to make it the current document. (See the section on opening a document )","title":"Smart Folders"},{"location":"smartfolders/#smart-folders","text":"A smart folder is a way of automatically producing a collection document, where the documents in the collection are those (belonging to the user) with a specified tag. Such a collection is created at the backend by the function SmartFolder.makeCollectionDocumentCmd . This function is invoked indirectly from the frontend by the function SmartFolder.makeCollectionDocument . The format of a smart folder document is | title Notes (Foo) [tags :folder, gettag:foo] The resulting collection document will be populated by all of the user's documents tagged with \"foo\". The old format is for the time being still operational: | title Notes (Foo) [tags :folder] | type folder get:foo ;","title":"Smart Folders"},{"location":"smartfolders/#creating-a-smart-folder","text":"A smart folder is created by the function SmartFolder.create . It creates the document and sends to to the backend via the message CreateDocument , which invokes the function Backend.Document.create","title":"Creating a Smart Folder"},{"location":"smartfolders/#sort-options","text":"The default sort option is to sort titles alphabetically (A to Z). The sort option may be changed by specifying a tag: sort:created-oldest-first sort:created-newest-first sort:modified-oldest-first sort:modified-newest-first sort:a-to-z sort:z-to-a","title":"Sort options"},{"location":"smartfolders/#rendering-a-smart-folder","text":"When the user click on a smart folder, the normal chaing of function calls is activated to make it the current document. (See the section on opening a document )","title":"Rendering a smart folder"},{"location":"stats/","text":"Stats & stuff 1/21/2023 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Language Files Lines Blanks Comments Code Complexity \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Elm 99 19176 4305 887 13984 871 Markdown 1 123 31 0 92 0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Total 100 19299 4336 887 14076 871 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Estimated Cost to Develop (organic) $434,008 Estimated Schedule Effort (organic) 10.02 months Estimated People Required (organic) 3.85 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Processed 595993 bytes, 0.596 megabytes (SI) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"Stats & stuff"},{"location":"stats/#stats-stuff","text":"1/21/2023 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Language Files Lines Blanks Comments Code Complexity \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Elm 99 19176 4305 887 13984 871 Markdown 1 123 31 0 92 0 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Total 100 19299 4336 887 14076 871 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Estimated Cost to Develop (organic) $434,008 Estimated Schedule Effort (organic) 10.02 months Estimated People Required (organic) 3.85 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Processed 595993 bytes, 0.596 megabytes (SI) \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500","title":"Stats &amp; stuff"}]}